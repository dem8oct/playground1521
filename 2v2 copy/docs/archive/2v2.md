ROLE  
You are a **Senior Full-Stack Engineer**.

TASK  
Build a **design-system-driven**, mobile-responsive, single-page web app that tracks a local 2v2 EA SPORTS FC “Kick Off Night” on PS5.

The app is for **4–10 human players** who play local 2v2 (or 2v1) matches. The goal is to:

1. Log all matches in a “game night” session.
2. Generate **player** and **pair** leaderboards.
3. Show a real-time, shared view for everyone in the room.

TECH STACK (MANDATORY)  
- **Front-end:** React + TypeScript + Vite  
- **Styling:** Tailwind CSS  
- **Backend / DB / Auth / Realtime:** Supabase  
- **State / Data fetching:** React Query (or similar) + Supabase client  
- **Hosting:** VPS (just prepare a standard Vite production build; no infra scripts)  

Do **not** generate any infra setup scripts or DevOps instructions. Focus on app architecture, components, and Supabase integration.

## Critical Requirements:

### Authentication:
✅ Configure Supabase client with EXPLICIT session persistence
✅ Use localStorage for session storage
✅ Set unique storageKey for the app
✅ Filter INITIAL_SESSION events in onAuthStateChange
✅ Add mounted flags to prevent race conditions
✅ Include proper cleanup functions

### Database:
✅ Use .maybeSingle() instead of .single() for optional records
✅ Add comprehensive error handling
✅ Include Row Level Security (RLS) policies
✅ Add proper indexes for performance

### Code Quality:
✅ Follow React best practices (hooks rules, proper dependencies)
✅ Add TypeScript types (if using TypeScript)
✅ Include error boundaries
✅ Add loading states for all async operations
✅ Use try-catch blocks consistently
✅ Add console logging for debugging (removable later)

### User Experience:
✅ Toast notifications for user feedback
✅ Loading skeletons (not just spinners)
✅ Proper empty states
✅ Error messages that guide users

### Documentation:
✅ Create SETUP.md with step-by-step instructions
✅ Create TROUBLESHOOTING.md for common issues
✅ Add .env.example with all required variables
✅ Include inline comments for complex logic

### Testing:
✅ Include manual testing scenarios
✅ Add instructions for testing auth flows
✅ Document expected behavior


----------------------------------------------------------------------
## 1. High-Level Product Behavior

### 1.1 Game Night Sessions
- There is **at most one active session** in the whole system for this MVP.
- A **session** represents a single “Kick Off Night” and is the container for:
  - Players participating that night
  - All matches played in that night
  - Aggregated stats & leaderboards
- A session:
  - Is created by a **logged-in initiator** (Supabase user).
  - Generates a **short join code** that other users can use.
  - Auto-expires after **10 hours** (status → `expired`).
  - Can be **ended** manually by the initiator (status → `ended`).
- Once ended/expired:
  - No more matches can be logged.
  - The data is still stored in the DB for viewing (MVP can be “current session only” or a simple sessions list).

### 1.2 Joining the Session
- Other people in the room can **join the active session using a code**:
  - They can join **anonymously** (no auth required) to view matches & leaderboards.
  - They may optionally log in via magic link to have their identity tied to the `players` records.
- All connected clients in the active session should see updates **in real time** via Supabase Realtime (matches list + leaderboards).

----------------------------------------------------------------------
## 2. Players & Identity

### 2.1 User-Level Profiles
- Implement **Supabase Auth with email magic link**.
- Each authenticated user has a **profile** row (e.g. `profiles` table):
  - `id` (UUID, matches auth user id)
  - `display_name`
  - `created_at`
- Profiles are **persistent** across sessions.

### 2.2 Session Players
- Each session has a list of **players participating that night**.
- A “player” for the session can be:
  - Mapped to an authenticated profile (preferred).
  - Or a guest nickname (no auth).
- Data model idea (`session_players`):
  - `id`
  - `session_id`
  - `profile_id` (nullable, if this is a logged-in user)
  - `display_name` (required; even if mapped to profile)
  - `created_at`
- MVP constraint:
  - Allow **4–10** players in a session.
  - Prevent duplicate names within the same session.

----------------------------------------------------------------------
## 3. Matches & Logging Flow

### 3.1 Match Constraints
Each logged match:

- Belongs to the **active session**.
- Involves **3 or 4 distinct players total**:
  - **Team A:** always 2 players.
  - **Team B:** 1 or 2 players.
- For each team:
  - Record optional **EA SPORTS FC club/team name** (this field is optional).
- Must include:
  - Goals for Team A
  - Goals for Team B
  - Match timestamp (default = now, editable)
  - Who logged the match (`logged_by` – linked to initiator or delegated logger)

### 3.2 Logging UX
- **Team assignment UX:** simple dropdowns, not drag & drop.
- Form requirements:
  - Select 3 or 4 distinct session players.
  - Assign exactly 2 to Team A.
  - Assign 1 or 2 to Team B.
  - UI must prevent invalid states:
    - Same player cannot be on both teams.
    - Must have at least 1 player on Team B.
- It should be quick and usable on a phone.

### 3.3 Session Roles
- **Initiator**:
  - Must be logged-in via Supabase magic link.
  - Creates the session & join code.
  - Can log matches.
  - Can **delegate** logging rights to one other player at a time (co-logger).
  - Can **end** the session (but **cannot reset it**; no destructive “reset” button).

- **Co-logger**:
  - Can log matches for the session.
  - Assigned by the initiator (by choosing from session players).

- **Other participants**:
  - Can join via code (anonymous or logged-in).
  - Can view matches & leaderboards in real time.

### 3.4 Editing / Deleting Matches
- Matches can be **edited** or **deleted** by:
  - The initiator, and
  - The delegated co-logger (for simplicity in this MVP).
- When a match is edited or deleted, the **derived stats** for players and pairs must be recalculated and persisted consistently.

----------------------------------------------------------------------
## 4. Stats & Leaderboards

### 4.1 Scoring Rules
Use standard football scoring:

- Win = 3 points
- Draw = 1 point
- Loss = 0 points
- A match may end in a **draw**.
- Each player’s:
  - **GF (Goals For)** = goals scored by their team.
  - **GA (Goals Against)** = goals conceded by their team.
  - **GD (Goal Difference)** = GF − GA.

### 4.2 Player Stats (per session)
For each player in the session, compute and store:

- MP (Matches Played)
- W (Wins)
- D (Draws)
- L (Losses)
- GF (Goals For)
- GA (Goals Against)
- GD (Goal Difference)
- Pts (Points)

**Sorting for player leaderboard:**

1. Points (descending)  
2. Goal Difference (descending)  
3. Goals For (descending)  
4. Alphabetical by player name  

### 4.3 Pair Stats (per session)
- A **pair** is defined as two players who start on the **same team** in a match.
- The pair is **unordered**: A+B == B+A.
- For each pair, compute stats **only for matches where they were teammates**:

  - MP, W, D, L  
  - GF, GA, GD, Pts  

- Display pair names in the leaderboard as: `"Ahmed & Salman"`.

**Sorting for pair leaderboard:**

Same as players:
1. Points  
2. GD  
3. GF  
4. Alphabetical by pair label (“Name1 & Name2”)  

### 4.4 Stats Persistence Strategy
- After each match insert/update:
  - Recalculate player and pair stats **from all matches** in that session on the server side (or in a trusted serverless function).
  - Persist aggregated stats in dedicated tables (e.g., `player_stats`, `pair_stats`).
- After any **edit or delete**:
  - Recompute and persist stats to keep everything consistent.

----------------------------------------------------------------------
## 5. Match History View

- Show a **reverse chronological** list of all matches in the active session.
- For each match display:
  - Time (e.g., `22:15`)
  - Teams with player names and goals:
    - `Team A: Ahmed, Salman — 3`
    - `Team B: Rami, Nasser — 2` (or just one player when 2v1)
  - Optional club names if entered (e.g. “Real Madrid vs PSG”).
  - Logged by (initiator or co-logger).
- Allow quick access to **edit** or **delete** actions for authorized users.

----------------------------------------------------------------------
## 6. Design System & UI/UX

The app should feel like a **tiny, polished internal tool**: clean, minimal, and reusable.

### 6.1 Design System (Small but Solid)
Implement a **small design system** in a `components/ui` (or similar) folder with:

- Button
- Input
- Select
- Card
- Table
- Badge/Tag (for statuses, e.g., “Active”, “Ended”)
- Page layout shell (header + content area)
- Tabs or Segmented Control (e.g. “Matches / Player Leaderboard / Pairs”)

Guidelines:

- Use **Tailwind** utility classes consistently.
- Keep the visual style minimal and modern.
- No heavy animations; at most very light hover and focus states.
- Ensure everything is mobile-first and looks good on narrow screens.

### 6.2 Main Screens
At minimum:

1. **Auth / Entry Screen**
   - Login via email magic link (Supabase).
   - Option to “Join session as guest” (if a session is active and you have a code).

2. **Session Lobby / Setup**
   - Create session (if none active) – initiator only.
   - Show join code.
   - Add/remove session players.
   - See which players are linked to profiles vs guests.
   - Assign co-logger.

3. **Dashboard (Core Screen)**
   - Tabs or sections for:
     - Match Logging form
     - Match History
     - Player Leaderboard
     - Pair Leaderboard
   - All sections update in real time for all connected clients.

4. **Post-Session State**
   - When session is ended/expired:
     - Show a “Session ended” state and keep the data read-only.

----------------------------------------------------------------------
## 7. Realtime Behavior

Use **Supabase Realtime** for the active session:

- Subscribe to relevant tables (e.g., `matches`, `player_stats`, `pair_stats`, possibly `session_players`).
- Any insert/update/delete in these tables for the active session should:
  - Update the local UI state.
  - Refresh visible lists/leaderboards without manual reload.

----------------------------------------------------------------------
## 8. Data Model (Supabase Tables – Outline)

Define a clear schema (you don’t have to be perfect with types, but be consistent):

- `sessions`
  - `id`
  - `initiator_user_id`
  - `join_code`
  - `status` (active, ended, expired)
  - `created_at`
  - `expires_at`

- `profiles`
  - `id` (matches Supabase auth user id)
  - `display_name`
  - `created_at`

- `session_players`
  - `id`
  - `session_id`
  - `profile_id` (nullable)
  - `display_name`
  - `created_at`

- `matches`
  - `id`
  - `session_id`
  - `logged_by_user_id`
  - `team_a_player_ids` (array of `session_player` ids; always length 2)
  - `team_b_player_ids` (array; length 1 or 2)
  - `team_a_club` (nullable string)
  - `team_b_club` (nullable string)
  - `team_a_goals`
  - `team_b_goals`
  - `played_at`
  - `created_at`
  - `updated_at`

- `player_stats`
  - `id`
  - `session_id`
  - `session_player_id`
  - `mp`, `w`, `d`, `l`, `gf`, `ga`, `gd`, `pts`

- `pair_stats`
  - `id`
  - `session_id`
  - `session_player_id_1`
  - `session_player_id_2`
  - `label` (e.g., `Ahmed & Salman`)
  - `mp`, `w`, `d`, `l`, `gf`, `ga`, `gd`, `pts`

Adjust or normalize as needed, but keep this spirit.

----------------------------------------------------------------------
## 9. Project Structure & Git Workflow

1. **Planning First**
   - Start by outputting a short implementation plan:
     - Main pages
     - Core components
     - Data access layer
     - Supabase setup steps (conceptual; no shell scripts)

2. **Repository Structure (Example)**
   - `src/`
     - `main.tsx`
     - `app.tsx`
     - `routes/`
     - `components/ui/` (design system)
     - `components/session/`
     - `components/matches/`
     - `components/leaderboards/`
     - `lib/supabase.ts`
     - `lib/stats.ts` (stat recalculation helpers)
   - Tailwind config, Vite config, etc.

3. **Git Branches**
   - Create logical branches (e.g., `feature/session-and-auth`, `feature/match-logging`, `feature/leaderboards`).
   - Implement features branch by branch with coherent commits.

IMPORTANT:  
- Do **not** generate any shell scripts, deployment scripts, or CI configs.  
- Do **not** write explanatory prose for humans beyond what’s necessary in comments.  
- Focus on well-structured, idiomatic code and clean separation of concerns.
